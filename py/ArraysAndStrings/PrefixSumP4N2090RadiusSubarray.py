"""
问题：
你有一个整数数组，同时你也有一个整数k。你需要计算数组中每个元素的“k半径平均数”。k半径平均数是指在一个元素的前k个和后k个元素（包括该元素自己）的平均值。如果在一个元素前后k个元素的范围内没有足够的元素，那么它的k半径平均数就是-1。你需要返回一个新数组，包含原数组中每个元素的k半径平均数。平均数应使用整数除法计算，即去掉小数部分。
思路：
这段代码首先处理了一些特殊情况：如果k等于0，那么每个元素的k半径平均数就是该元素本身；如果数组的长度小于2k+1，那么没有任何元素的k半径平均数存在。然后，代码创建了一个前缀和数组，该数组的每个元素都是输入数组中到当前位置为止的所有元素的和。最后，对于每个可能的中心元素（即那些前后都至少有k个元素的元素），代码计算其k半径平均数并将结果存储在对应的位置。计算k半径平均数的方法是，先找出前k个元素和后k个元素的总和，然后除以2k+1。使用前缀和数组，可以很快地找出前k个元素和后k个元素的总和。
"""
class Solution:
    def getAverages(self, nums: list[int], k: int) -> list[int]:
        if k == 0: #如果半径为0，那么任何一个点的平均值都是它本身，因为只有它自己。
            return nums
        
        n = len(nums)
        avgs = [-1] * n

        if 2 * k + 1 > n: #如果区间大于数组长度，说明不可能有该区间，那么任何一个点的平均值都是-1
            return avgs
        
        prefix = [0] * (n + 1) #前0项和，前1项和，...，前n项和
        for i in range(n):
            prefix[i + 1] = prefix[i] + nums[i]

        # 0 1 2 3 4, k = 1, n = 5, (1,4)前闭后开
        for i in range(k, n - k): 
            #[0]1 [1]2 [2]3 [3]4 [4]5, i=2, k=1, n=5, 区间最大端是3，最小端是1，区间和是第4项前缀和减去第1项前缀和
            avgs[i] = prefix[i + k + 1] - prefix[i - k] // (2 * k + 1)
        
        return avgs

        
